# imports
import tkinter as tk
from tkinter import ttk
import datetime # one module for working with dates and times




# The MainWindow class creates a custom GUI window based on the tkinter window (tk.Tk)
# It has an __init__() method, and three additional methods (new_note(), open_notebook(), and save_notebook())
# These methods correspond to new, open, and save buttons in the window.
# The new_note method calls the NoteForm class to create a new note form top level window.

class MainWindow(tk.Tk):
    def __init__(self):  #initialize the main window
        super().__init__() # initialize it as a tkinter window
        
        self.geometry("600x400") # set the default window size
        self.title('Notebook') # set the default window title
        self.notebook = [] # initialize an attribute named 'notebook' as an empty list
        self.current_note = None

        create_button = tk.Button(self, text='Create New Note', command=self.new_note)
        create_button.grid(row=0, column=0, padx=10, pady=10)

        save_button = tk.Button(self, text='Save File', command=self.save_notebook)
        save_button.grid(row=0, column=1, padx=10, pady=10)

        quit_button = tk.Button(self, text='Quit Application', command=self.destroy)
        quit_button.grid(row=0, column=2, padx=10, pady=10)

        edit_button = tk.Button(self, text='Edit Note', command=self.edit_note)
        edit_button.grid(row=0, column=3, padx=10, pady=10)

        title_label = tk.Label(self, text='Notes')
        title_label.grid(row=1, column=0, padx=2, pady=2)

        self.read_notebook_file()
        self.refresh_notes_list()

        self.mainloop()   

    def read_notebook_file(self):
        file = open('INST326_NOTEBOOK.txt', 'r')
        notes = file.readlines()
        for note in notes:
            fields = note.split('\t')
            if len(fields) < 6:
                continue
            new_note_dict = {'title': fields[0], 'text': fields[1], 'author':fields[2], 'code_text': fields[3], 'links': fields[4], 'tags': fields[5]}
            new_note = Note(new_note_dict)
            self.notebook.append(new_note)

    def refresh_notes_list(self):
        i = 2
        for note in self.notebook:
            note_button = tk.Button(self, text=note.title, command=lambda current_note=note: self.open_notebook(current_note))
            note_button.grid(row=i, column=0, padx=10, pady=10, sticky='E')
            i += 1

    def new_note(self):
        note_window = NoteForm(self, self.notebook, None)
        return None

    def open_notebook(self, current_note):
        self.current_note = current_note
        note_window = NoteForm(self, self.notebook, self.current_note)
        return None
   
    def edit_note(self, current_note):
        self.current_note = current_note
        note_window = NoteForm(self, self.notebook, self.current_note)
        return None

    def save_notebook(self):
        with open("INST326_NOTEBOOK.txt", "w") as f:
            for notes in self.notebook:
                f.write(f"\n{notes.title}\t{notes.text}\t{notes.author}\t{notes.code_text}\t{notes.links}\t{notes.tags}")
        return None

# the NoteForm() class creates a Toplevel window that is a note form containing fields for
# data entry for title, text, link, and tags. It also calculates a meta field with date, time, and timezone
# the Noteform class has an __init__() method, and a submit() method that is called by a submit button
# the class may contain additional methods to perform tasks like calculating the metadata, for example
# the submit method calls the MakeNote class that transforms the the entered data into a new note object.

class NoteForm(tk.Toplevel):
    def __init__(self, master, notebook, note): # initialize the new object
        super().__init__(master) # initialize it as a toplevel window
        self.notebook = notebook 
        self.current_note = note

        # title
        title_label = tk.Label(self, bg='light gray', text='Note Title:')
        self.note_title = tk.Entry(self, width=80)

        title_label.grid(row=0, column=0, padx=2, pady=2, sticky='E')
        self.note_title.grid(row=0, column=1, padx=10, pady=2, sticky='W')

        # text
        text_label = tk.Label(self, bg='light gray', text='Note Text:')
        self.note_text = tk.Text(self, height=5, width=60)

        text_label.grid(row=1, column=0, padx=2, pady=2, sticky='E')
        self.note_text.grid(row=1, column=1, padx=10, pady=2, sticky='W')

        # author
        author_label = tk.Label(self, bg='light gray', text='Author:')
        self.note_author = tk.Entry(self, width=80)

        author_label.grid(row=2, column=0, padx=2, pady=2, sticky='E')
        self.note_author.grid(row=2, column=1, padx=10, pady=2, sticky='W')

        # code text
        self.code_text = tk.StringVar()

        code_label = tk.Label(self, bg='light gray', text='Code Text:')
        self.code_entry = tk.Entry(self, textvariable=self.code_text, width=80)
        self.code_text_editable = False

        code_label.grid(row=3, column=0, padx=2, pady=2, sticky='E')
        self.code_entry.grid(row=3, column=1, padx=10, pady=10, sticky='W')

        # edit code button
        edit_code_button = tk.Button(self, text='Edit Code', command=self.edit_code)
        edit_code_button.grid(row=6, column=0, padx=10, pady=10, sticky='W')

        # save edit button
        save_edit_button = tk.Button(self, text='Save Edit', command=self.save_edit)
        save_edit_button.grid(row=6, column=1, padx=10, pady=10, sticky='W')

        # links
        links_label = tk.Label(self, bg='light gray', text='Note Links:')
        self.note_links = tk.Entry(self, width=80)

        links_label.grid(row=4, column=0, padx=2, pady=2, sticky='E')
        self.note_links.grid(row=4, column=1, padx=10, pady=10, sticky='W')

        # tags
        tags_label = tk.Label(self, bg='light gray', text='Note Tags:')
        self.note_tags = tk.Entry(self, width=80)

        tags_label.grid(row=5, column=0, padx=2, pady=2, sticky='E')
        self.note_tags.grid(row=5, column=1, padx=10, pady=2, sticky='W')

        # submit button
        submit_button = tk.Button(self, text='Submit', command=self.submit)

        # if viewing an existing note, remove submit button and disable inputs
        if note is None:
            submit_button.grid(row=7, column=1, padx=10, pady=10, sticky='W')
        else:
            self.note_title.insert(0, note.title)
            self.note_text.insert("1.0", note.text)
            self.note_author.insert(0, note.author)
            self.code_entry.insert(0, note.code_text)
            self.note_links.insert(0, note.links) 
            self.note_tags.insert(0, note.tags) 

            self.note_title.config(state=tk.DISABLED) 
            self.note_text.config(state=tk.DISABLED) 
            self.code_entry.config(state=tk.DISABLED) 
            self.note_links.config(state=tk.DISABLED) 
            self.note_tags.config(state=tk.DISABLED) 

    def edit_code(self):
        if not self.code_text_editable:
            self.code_entry.config(state=tk.NORMAL)
            self.code_text_editable = True
        else:
            self.code_entry.config(state=tk.DISABLED)
            self.code_text_editable = False

    def save_edit(self):
        if self.current_note:
            self.current_note.code_text = self.code_entry.get()
            self.code_entry.config(state=tk.DISABLED)
            self.code_text_editable = False
        else:
            self.code_text.set(self.code_entry.get())
            self.code_entry.config(state=tk.DISABLED)
            self.code_text_editable = False



    def submit(self):
        new_note_dict = {'title': self.note_title.get(), 
                         'text': self.note_text.get("1.0", "end-1c"), 
                         'code_text': self.code_entry.get(),
                         'links': self.note_links.get(), 
                         'tags': self.note_tags.get(),
                         'author': self.note_author.get()}
        new_note = Note(new_note_dict)
        self.notebook.append(new_note)
        self.destroy()
        self.master.refresh_notes_list()
        return None

    
# The Note class takes a dictionary containing the data entered into the form window,
# and transforms it into a new note object.
# At present the note objects have attributes but no methods.
class Note():
    def __init__(self, note_dict):
        self.title = note_dict["title"] 
        self.text = note_dict["text"] 
        self.links = note_dict["links"] 
        self.tags = note_dict["tags"] 
        self.author = note_dict["author"]
        if "code_text" in note_dict:
            self.code_text = note_dict["code_text"]
 
            
#Snippet Class
class Snippet(tk.Toplevel):
    def __init__(self, master, snippet):
        super().__init__(master)
        self.snippet = snippet

        # code text
        code_label = tk.Label(self, bg='light gray', text='Code Text:')
        self.code_text = tk.Text(self, height=5, width=60)

        code_label.grid(row=1, column=0, padx=2, pady=2, sticky='E')
        self.code_text.grid(row=1, column=1, padx=10, pady=2, sticky='W')

        # if viewing an existing snippet, populate the code text
        if self.snippet:
            self.code_text.insert("1.0", self.snippet.code_text)

        # submit button
        save_edit_button = tk.Button(self, text='Save Edit', command=self.save_edit)
        save_edit_button.grid(row=2, column=1, padx=10, pady=10, sticky='W')

    def save_edit(self):
        if self.snippet:
            self.snippet.code_text = self.code_text.get("1.0", "end-1c")
        else:
            self.master.code_text.set(self.code_text.get("1.0", "end-1c"))
        self.destroy()



    
# main execution
if __name__ == '__main__':
    main_window = MainWindow() # this creates a notebook / main window called main_window. You may change the name if you want
    main_window.mainloop()

file = open('INST326_NOTEBOOK.txt', 'r')
notes = file.readlines()
for note in notes:
    fields = note.split('\t')
    if len(fields) < 4:
        continue
    new_note_dict = {'title': fields[0], 'text': fields[1], 'links': fields[2], 'tags': fields[3]}
    print(new_note_dict)
